const mongoose = require('mongoose');

/**
 * CounselingRecommendation Model - Pattern-based mentoring and counseling
 * Automatically generates counseling recommendations based on student patterns
 */
const CounselingRecommendationSchema = new mongoose.Schema({
  studentId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'Student', 
    required: true,
    index: true 
  },
  
  // Recommendation details
  recommendationType: {
    type: String,
    enum: [
      'academic_support',
      'behavioral_counseling',
      'mental_health',
      'career_guidance',
      'stress_management',
      'time_management',
      'peer_relationship',
      'family_issues',
      'attendance_improvement',
      'motivation_boost',
      'skill_development',
      'other'
    ],
    required: true
  },
  
  priority: {
    type: String,
    enum: ['low', 'medium', 'high', 'urgent'],
    required: true
  },
  
  // Reason for recommendation
  reason: { type: String, required: true },
  description: { type: String },
  
  // Detected patterns that triggered this
  patterns: [{
    type: String,
    severity: String,
    occurrences: Number,
    description: String
  }],
  
  // Risk metrics that triggered this
  triggerMetrics: {
    attendancePercentage: Number,
    averageMarks: Number,
    negativeRemarks: Number,
    behaviorScore: Number,
    activityLevel: Number,
    monitoringScore: Number
  },
  
  // Recommended counselor
  recommendedCounselor: {
    counselorId: { type: mongoose.Schema.Types.ObjectId, ref: 'Teacher' },
    counselorName: String,
    specialization: String
  },
  
  // Assignment
  assignedTo: {
    counselorId: { type: mongoose.Schema.Types.ObjectId, ref: 'Teacher' },
    counselorName: String,
    assignedAt: Date
  },
  
  // Session details
  sessions: [{
    sessionDate: Date,
    duration: Number, // in minutes
    notes: String,
    outcome: String,
    followUpRequired: Boolean,
    nextSessionDate: Date,
    conductedBy: {
      counselorId: { type: mongoose.Schema.Types.ObjectId, ref: 'Teacher' },
      counselorName: String
    }
  }],
  
  // Progress tracking
  progress: {
    status: {
      type: String,
      enum: ['pending', 'in_progress', 'completed', 'closed'],
      default: 'pending'
    },
    improvementSeen: { type: Boolean, default: false },
    sessionsCompleted: { type: Number, default: 0 },
    totalSessionsPlanned: { type: Number, default: 3 },
    lastSessionDate: Date,
    nextSessionDate: Date
  },
  
  // Outcome
  outcome: {
    resolved: { type: Boolean, default: false },
    resolvedAt: Date,
    summary: String,
    recommendations: [String],
    followUpRequired: Boolean,
    followUpDate: Date
  },
  
  // Auto-generated flag
  isAutoGenerated: { type: Boolean, default: true },
  generatedBy: { type: String, default: 'system' },
  
  // Manual override
  manuallyCreated: { type: Boolean, default: false },
  createdBy: {
    userId: { type: mongoose.Schema.Types.ObjectId },
    userName: String,
    userType: String
  },
  
  // Metadata
  academicYear: { type: String },
  semester: { type: Number },
  
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

// Indexes
CounselingRecommendationSchema.index({ studentId: 1, createdAt: -1 });
CounselingRecommendationSchema.index({ 'progress.status': 1, priority: -1 });
CounselingRecommendationSchema.index({ 'assignedTo.counselorId': 1 });

// Pre-save hook
CounselingRecommendationSchema.pre('save', function(next) {
  this.updatedAt = Date.now();
  next();
});

// Method to add session
CounselingRecommendationSchema.methods.addSession = function(sessionData) {
  this.sessions.push({
    ...sessionData,
    sessionDate: sessionData.sessionDate || new Date()
  });
  
  this.progress.sessionsCompleted = this.sessions.length;
  this.progress.lastSessionDate = sessionData.sessionDate || new Date();
  this.progress.status = 'in_progress';
  
  if (this.progress.sessionsCompleted >= this.progress.totalSessionsPlanned) {
    this.progress.status = 'completed';
  }
  
  this.updatedAt = new Date();
};

// Method to assign to counselor
CounselingRecommendationSchema.methods.assignCounselor = function(counselorId, counselorName) {
  this.assignedTo = {
    counselorId,
    counselorName,
    assignedAt: new Date()
  };
  this.progress.status = 'in_progress';
  this.updatedAt = new Date();
};

// Method to mark as resolved
CounselingRecommendationSchema.methods.markResolved = function(summary, recommendations = []) {
  this.outcome.resolved = true;
  this.outcome.resolvedAt = new Date();
  this.outcome.summary = summary;
  this.outcome.recommendations = recommendations;
  this.progress.status = 'completed';
  this.updatedAt = new Date();
};

// Static method to get pending recommendations by priority
CounselingRecommendationSchema.statics.getPendingByPriority = async function(priority) {
  return await this.find({
    'progress.status': { $in: ['pending', 'in_progress'] },
    priority
  })
  .populate('studentId', 'name rollNumber email imageURL')
  .sort({ createdAt: -1 });
};

// Static method to get recommendations for counselor
CounselingRecommendationSchema.statics.getForCounselor = async function(counselorId) {
  return await this.find({
    'assignedTo.counselorId': counselorId,
    'progress.status': { $in: ['pending', 'in_progress'] }
  })
  .populate('studentId', 'name rollNumber email')
  .sort({ priority: -1, createdAt: -1 });
};

// Static method to get urgent recommendations
CounselingRecommendationSchema.statics.getUrgent = async function() {
  return await this.find({
    priority: 'urgent',
    'progress.status': { $in: ['pending', 'in_progress'] }
  })
  .populate('studentId', 'name rollNumber email imageURL')
  .sort({ createdAt: -1 });
};

module.exports = mongoose.model('CounselingRecommendation', CounselingRecommendationSchema);
